import{V as b,Y as g,L as l,E as w,H as D}from"./sparkTitle.DCU_Odjx.js";import"./cn.Bh4i3_zX.js";import"./index.NEDEFKed.js";import"./motion.DhRAmCJf.js";const m=.5,x=0,v=1,M=60,z=0,F=.01;function O(n){const i=n.initialPosition,{dx:s,dy:o}=b(i,n.position),y=Math.abs(s),t=Math.abs(o),{maxDistance:c}=n.retina,a=c.horizontal,f=c.vertical;if(!a&&!f)return;const h=(a&&y>=a)??!1,u=(f&&t>=f)??!1;if((h||u)&&!n.misplaced)n.misplaced=!!a&&y>a||!!f&&t>f,a&&(n.velocity.x=n.velocity.y*m-n.velocity.x),f&&(n.velocity.y=n.velocity.x*m-n.velocity.y);else if((!a||y<a)&&(!f||t<f)&&n.misplaced)n.misplaced=!1;else if(n.misplaced){const d=n.position,e=n.velocity;a&&(d.x<i.x&&e.x<x||d.x>i.x&&e.x>x)&&(e.x*=-g()),f&&(d.y<i.y&&e.y<x||d.y>i.y&&e.y>x)&&(e.y*=-g())}}async function k(n,i,s,o,y,t){await r(n,t);const c=n.gravity,a=c?.enable&&c.inverse?-v:v;y&&s&&(n.velocity.x+=y*t.factor/(M*s)),c?.enable&&s&&(n.velocity.y+=a*(c.acceleration*t.factor)/(M*s));const f=n.moveDecay;n.velocity.multTo(f);const h=n.velocity.mult(s);c?.enable&&o>x&&(!c.inverse&&h.y>=x&&h.y>=o||c.inverse&&h.y<=x&&h.y<=-o)&&(h.y=a*o,s&&(n.velocity.y=h.y/s));const u=n.options.zIndex,d=(v-n.zIndexFactor)**u.velocityRate;h.multTo(d);const{position:e}=n;e.addTo(h),i.vibrate&&(e.x+=Math.sin(e.x*Math.cos(e.y)),e.y+=Math.cos(e.y*Math.sin(e.x)))}function p(n,i){const s=n.container;if(!n.spin)return;const o={x:n.spin.direction==="clockwise"?Math.cos:Math.sin,y:n.spin.direction==="clockwise"?Math.sin:Math.cos};n.position.x=n.spin.center.x+n.spin.radius*o.x(n.spin.angle),n.position.y=n.spin.center.y+n.spin.radius*o.y(n.spin.angle),n.spin.radius+=n.spin.acceleration;const y=Math.max(s.canvas.size.width,s.canvas.size.height),t=y*m;n.spin.radius>t?(n.spin.radius=t,n.spin.acceleration*=-v):n.spin.radius<z&&(n.spin.radius=z,n.spin.acceleration*=-v),n.spin.angle+=i*F*(v-n.spin.radius/y)}async function r(n,i){const s=n.options,o=s.move.path;if(!o.enable)return;if(n.lastPathTime<=n.pathDelay){n.lastPathTime+=i.value;return}const t=await n.pathGenerator?.generate(n,i);t&&n.velocity.addTo(t),o.clamp&&(n.velocity.x=l(n.velocity.x,-v,v),n.velocity.y=l(n.velocity.y,-v,v)),n.lastPathTime-=n.pathDelay}function A(n){return n.slow.inRange?n.slow.factor:v}function E(n){const i=n.container,s=n.options,o=s.move.spin;if(!o.enable)return;const y=o.position??{x:50,y:50},t=.01,c={x:y.x*t*i.canvas.size.width,y:y.y*t*i.canvas.size.height},a=n.getPosition(),f=w(a,c),h=D(o.acceleration);n.retina.spinAcceleration=h*i.retina.pixelRatio;const u=0;n.spin={center:c,direction:n.velocity.x>=u?"clockwise":"counter-clockwise",angle:n.velocity.angle,radius:f,acceleration:n.retina.spinAcceleration}}export{O as applyDistance,r as applyPath,A as getProximitySpeedFactor,E as initSpin,k as move,p as spin};
