const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["_astro/index.BX0mCmLm.js","_astro/sparkTitle.DCU_Odjx.js","_astro/cn.Bh4i3_zX.js","_astro/index.NEDEFKed.js","_astro/motion.DhRAmCJf.js"])))=>i.map(i=>d[i]);
import{_ as O}from"./sparkTitle.DCU_Odjx.js";import"./cn.Bh4i3_zX.js";import"./index.NEDEFKed.js";import"./motion.DhRAmCJf.js";const R=[0,4,2,1],G=[8,8,4,2];class U{constructor(a){this.pos=0,this.data=new Uint8ClampedArray(a)}getString(a){const s=this.data.slice(this.pos,this.pos+a);return this.pos+=s.length,s.reduce((n,f)=>n+String.fromCharCode(f),"")}nextByte(){return this.data[this.pos++]}nextTwoBytes(){return this.pos+=2,this.data[this.pos-2]+(this.data[this.pos-1]<<8)}readSubBlocks(){let a="",s=0;const n=0,f=0;do{s=this.data[this.pos++];for(let o=s;--o>=n;a+=String.fromCharCode(this.data[this.pos++]));}while(s!==f);return a}readSubBlocksBin(){let a=this.data[this.pos],s=0;const n=0,f=1;for(let e=0;a!==n;e+=a+f,a=this.data[this.pos+e])s+=a;const o=new Uint8Array(s);a=this.data[this.pos++];for(let e=0;a!==n;a=this.data[this.pos++])for(let r=a;--r>=n;o[e++]=this.data[this.pos++]);return o}skipSubBlocks(){for(const a=1,s=0;this.data[this.pos]!==s;this.pos+=this.data[this.pos]+a);this.pos++}}const u={x:0,y:0},N=0,L=.5,$=0,A=0,z=0;function _(t,a){const s=[];for(let n=0;n<a;n++)s.push({r:t.data[t.pos],g:t.data[t.pos+1],b:t.data[t.pos+2]}),t.pos+=3;return s}function Q(t,a,s,n){switch(t.nextByte()){case 249:{const f=a.frames[s(!1)];t.pos++;const o=t.nextByte();f.GCreserved=(o&224)>>>5,f.disposalMethod=(o&28)>>>2,f.userInputDelayFlag=(o&2)===2;const e=(o&1)===1;f.delayTime=t.nextTwoBytes()*10;const r=t.nextByte();e&&n(r),t.pos++;break}case 255:{t.pos++;const f={identifier:t.getString(8),authenticationCode:t.getString(3),data:t.readSubBlocksBin()};a.applicationExtensions.push(f);break}case 254:{a.comments.push([s(!1),t.readSubBlocks()]);break}case 1:{if(a.globalColorTable.length===0)throw new EvalError("plain text extension without global color table");t.pos++,a.frames[s(!1)].plainTextData={left:t.nextTwoBytes(),top:t.nextTwoBytes(),width:t.nextTwoBytes(),height:t.nextTwoBytes(),charSize:{width:t.nextTwoBytes(),height:t.nextTwoBytes()},foregroundColor:t.nextByte(),backgroundColor:t.nextByte(),text:t.readSubBlocks()};break}default:t.skipSubBlocks();break}}async function W(t,a,s,n,f,o){const e=a.frames[n(!0)];e.left=t.nextTwoBytes(),e.top=t.nextTwoBytes(),e.width=t.nextTwoBytes(),e.height=t.nextTwoBytes();const r=t.nextByte(),x=(r&128)===128,d=(r&64)===64;e.sortFlag=(r&32)===32,e.reserved=(r&24)>>>3;const c=1<<(r&7)+1;x&&(e.localColorTable=_(t,c));const m=l=>{const{r:h,g:p,b:i}=(x?e.localColorTable:a.globalColorTable)[l];return l!==f(null)?{r:h,g:p,b:i,a:255}:{r:h,g:p,b:i,a:s?~~((h+p+i)/3):0}},B=(()=>{try{return new ImageData(e.width,e.height,{colorSpace:"srgb"})}catch(l){if(l instanceof DOMException&&l.name==="IndexSizeError")return null;throw l}})();if(B==null)throw new EvalError("GIF frame size is to large");const k=t.nextByte(),E=t.readSubBlocksBin(),w=1<<k,D=(l,h)=>{const p=l>>>3,i=l&7;return(E[p]+(E[p+1]<<8)+(E[p+2]<<16)&(1<<h)-1<<i)>>>i};if(d){for(let l=0,h=k+1,p=0,i=[[0]],I=0;I<4;I++){if(R[I]<e.height){let g=0,T=0,C=!1;for(;!C;){const b=l;if(l=D(p,h),p+=h+1,l===w){h=k+1,i.length=w+2;for(let y=0;y<i.length;y++)i[y]=y<w?[y]:[]}else{l>=i.length?i.push(i[b].concat(i[b][0])):b!==w&&i.push(i[b].concat(i[l][0]));for(const y of i[l]){const{r:v,g:F,b:P,a:M}=m(y);B.data.set([v,F,P,M],R[I]*e.width+G[I]*T+g%(e.width*4)),g+=4}i.length===1<<h&&h<12&&h++}g===e.width*4*(T+1)&&(T++,R[I]+G[I]*T>=e.height&&(C=!0))}}o?.(t.pos/(t.data.length-1),n(!1)+1,B,{x:e.left,y:e.top},{width:a.width,height:a.height})}e.image=B,e.bitmap=await createImageBitmap(B)}else{let l=0,h=k+1,p=0,i=-4,I=!1;const g=[[0]];for(;!I;){const T=l;if(l=D(p,h),p+=h,l===w){h=k+1,g.length=w+2;for(let C=0;C<g.length;C++)g[C]=C<w?[C]:[]}else{if(l===w+1){I=!0;break}l>=g.length?g.push(g[T].concat(g[T][0])):T!==w&&g.push(g[T].concat(g[l][0]));for(const C of g[l]){const{r:b,g:y,b:v,a:F}=m(C);B.data.set([b,y,v,F],i+=4)}g.length>=1<<h&&h<12&&h++}}e.image=B,e.bitmap=await createImageBitmap(B),o?.((t.pos+1)/t.data.length,n(!1)+1,e.image,{x:e.left,y:e.top},{width:a.width,height:a.height})}}async function j(t,a,s,n,f,o){switch(t.nextByte()){case 59:return!0;case 44:await W(t,a,s,n,f,o);break;case 33:Q(t,a,n,f);break;default:throw new EvalError("undefined block found")}return!1}function q(t){for(const a of t.applicationExtensions)if(a.identifier+a.authenticationCode==="NETSCAPE2.0")return a.data[1]+(a.data[2]<<8);return NaN}async function H(t,a,s){s||(s=!1);const n=await fetch(t);if(!n.ok&&n.status===404)throw new EvalError("file not found");const f=await n.arrayBuffer(),o={width:0,height:0,totalTime:0,colorRes:0,pixelAspectRatio:0,frames:[],sortFlag:!1,globalColorTable:[],backgroundImage:new ImageData(1,1,{colorSpace:"srgb"}),comments:[],applicationExtensions:[]},e=new U(new Uint8ClampedArray(f));if(e.getString(6)!=="GIF89a")throw new Error("not a supported GIF file");o.width=e.nextTwoBytes(),o.height=e.nextTwoBytes();const r=e.nextByte(),x=(r&128)===128;o.colorRes=(r&112)>>>4,o.sortFlag=(r&8)===8;const d=1<<(r&7)+1,c=e.nextByte();o.pixelAspectRatio=e.nextByte(),o.pixelAspectRatio!==0&&(o.pixelAspectRatio=(o.pixelAspectRatio+15)/64),x&&(o.globalColorTable=_(e,d));const m=(()=>{try{return new ImageData(o.width,o.height,{colorSpace:"srgb"})}catch(i){if(i instanceof DOMException&&i.name==="IndexSizeError")return null;throw i}})();if(m==null)throw new Error("GIF frame size is to large");const{r:B,g:k,b:E}=o.globalColorTable[c];m.data.set(x?[B,k,E,255]:[0,0,0,0]);for(let i=4;i<m.data.length;i*=2)m.data.copyWithin(i,0,i);o.backgroundImage=m;let w=-1,D=!0,l=-1;const h=i=>(i&&(D=!0),w),p=i=>(i!=null&&(l=i),l);try{do D&&(o.frames.push({left:0,top:0,width:0,height:0,disposalMethod:0,image:new ImageData(1,1,{colorSpace:"srgb"}),plainTextData:null,userInputDelayFlag:!1,delayTime:0,sortFlag:!1,localColorTable:[],reserved:0,GCreserved:0}),w++,l=-1,D=!1);while(!await j(e,o,s,h,p,a));o.frames.length--;for(const i of o.frames){if(i.userInputDelayFlag&&i.delayTime===0){o.totalTime=1/0;break}o.totalTime+=i.delayTime}return o}catch(i){throw i instanceof EvalError?new Error(`error while parsing frame ${w} "${i.message}"`):i}}function Y(t){const{context:a,radius:s,particle:n,delta:f}=t,o=n.image;if(!o?.gifData||!o.gif)return;const e=new OffscreenCanvas(o.gifData.width,o.gifData.height),r=e.getContext("2d");if(!r)throw new Error("could not create offscreen canvas context");r.imageSmoothingQuality="low",r.imageSmoothingEnabled=!1,r.clearRect(u.x,u.y,e.width,e.height),n.gifLoopCount===void 0&&(n.gifLoopCount=o.gifLoopCount??z);let x=n.gifFrame??N;const d={x:-o.gifData.width*L,y:-o.gifData.height*L},c=o.gifData.frames[x];if(n.gifTime===void 0&&(n.gifTime=$),!!c.bitmap){switch(a.scale(s/o.gifData.width,s/o.gifData.height),c.disposalMethod){case 4:case 5:case 6:case 7:case 0:r.drawImage(c.bitmap,c.left,c.top),a.drawImage(e,d.x,d.y),r.clearRect(u.x,u.y,e.width,e.height);break;case 1:r.drawImage(c.bitmap,c.left,c.top),a.drawImage(e,d.x,d.y);break;case 2:r.drawImage(c.bitmap,c.left,c.top),a.drawImage(e,d.x,d.y),r.clearRect(u.x,u.y,e.width,e.height),o.gifData.globalColorTable.length?r.putImageData(o.gifData.backgroundImage,d.x,d.y):r.putImageData(o.gifData.frames[A].image,d.x+c.left,d.y+c.top);break;case 3:{const m=r.getImageData(u.x,u.y,e.width,e.height);r.drawImage(c.bitmap,c.left,c.top),a.drawImage(e,d.x,d.y),r.clearRect(u.x,u.y,e.width,e.height),r.putImageData(m,u.x,u.y)}break}if(n.gifTime+=f.value,n.gifTime>c.delayTime){if(n.gifTime-=c.delayTime,++x>=o.gifData.frames.length){if(--n.gifLoopCount<=z)return;x=A,r.clearRect(u.x,u.y,e.width,e.height)}n.gifFrame=x}a.scale(o.gifData.width/s,o.gifData.height/s)}}async function Z(t){if(t.type!=="gif"){const{loadImage:a}=await O(async()=>{const{loadImage:s}=await import("./index.BX0mCmLm.js").then(n=>n.U);return{loadImage:s}},__vite__mapDeps([0,1,2,3,4]));await a(t);return}t.loading=!0;try{t.gifData=await H(t.source),t.gifLoopCount=q(t.gifData)??z,t.gifLoopCount||(t.gifLoopCount=1/0)}catch{t.error=!0}t.loading=!1}export{H as decodeGIF,Y as drawGif,q as getGIFLoopAmount,Z as loadGifImage};
