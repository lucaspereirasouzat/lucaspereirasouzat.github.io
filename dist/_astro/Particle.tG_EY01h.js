import{a3 as S,a4 as G,a5 as O,$ as V,H as D,a6 as A,s as H,Y as L,c as q,E as N,L as Z,F as $,a7 as B,W as J,a8 as F,N as b,q as W,a9 as Y,m as j,f as E,J as K}from"./sparkTitle.DCU_Odjx.js";import{l as Q,I as U}from"./Container.BPwq3Cx4.js";import{g as X}from"./CanvasUtils.5nKfh4B1.js";import"./cn.Bh4i3_zX.js";import"./index.NEDEFKed.js";import"./motion.DhRAmCJf.js";import"./OptionsColor.BuOxyFYl.js";import"./ValueWithRandom.t-Fg5jCW.js";import"./Circle.BsfAXaX2.js";const I=0,_=2,R=.5,tt=2;function it(r,e,o,i){const s=e.options[r];if(s)return E({close:e.close,fill:e.fill},b(s,o,i))}function et(r,e,o,i){const s=e.options[r];if(s)return E({close:e.close,fill:e.fill},b(s,o,i))}function M(r){if(!K(r.outMode,r.checkModes))return;const e=r.radius*_;r.coord>r.maxCoord-e?r.setCb(-r.radius):r.coord<e&&r.setCb(r.radius)}class pt{constructor(e,o){this.container=o,this._calcPosition=(i,s,t,n=I)=>{for(const[,p]of i.plugins){const c=p.particlePosition!==void 0?p.particlePosition(s,this):void 0;if(c)return S.create(c.x,c.y,t)}const h=i.canvas.size,l=G({size:h,position:s}),a=S.create(l.x,l.y,t),m=this.getRadius(),f=this.options.move.outModes,d=p=>{M({outMode:p,checkModes:["bounce"],coord:a.x,maxCoord:i.canvas.size.width,setCb:c=>a.x+=c,radius:m})},v=p=>{M({outMode:p,checkModes:["bounce"],coord:a.y,maxCoord:i.canvas.size.height,setCb:c=>a.y+=c,radius:m})};return d(f.left??f.default),d(f.right??f.default),v(f.top??f.default),v(f.bottom??f.default),this._checkOverlap(a,n)?this._calcPosition(i,void 0,t,n+1):a},this._calculateVelocity=()=>{const i=O(this.direction),s=i.copy(),t=this.options.move;if(t.direction==="inside"||t.direction==="outside")return s;const n=V(D(t.angle.value)),h=V(D(t.angle.offset)),l={left:h-n*R,right:h+n*R};return t.straight||(s.angle+=A(H(l.left,l.right))),t.random&&typeof t.speed=="number"&&(s.length*=L()),s},this._checkOverlap=(i,s=I)=>{const t=this.options.collisions,n=this.getRadius();if(!t.enable)return!1;const h=t.overlap;if(h.enable)return!1;const l=h.retries;if(l>=0&&s>l)throw new Error(`${q} particle is overlapping and can't be placed`);return!!this.container.particles.find(m=>N(i,m.position)<n+m.getRadius())},this._getRollColor=i=>{if(!i||!this.roll||!this.backColor&&!this.roll.alter)return i;const s=1,t=0,n=this.roll.horizontal&&this.roll.vertical?_*s:s,h=this.roll.horizontal?Math.PI*R:t;return Math.floor(((this.roll.angle??t)+h)/(Math.PI/n))%_?this.backColor?this.backColor:this.roll.alter?X(i,this.roll.alter.type,this.roll.alter.value):i:i},this._initPosition=i=>{const s=this.container,t=D(this.options.zIndex.value),n=0;this.position=this._calcPosition(s,i,Z(t,n,s.zLayers)),this.initialPosition=this.position.copy();const h=s.canvas.size,l=0;switch(this.moveCenter={...$(this.options.move.center,h),radius:this.options.move.center.radius??l,mode:this.options.move.center.mode??"percent"},this.direction=B(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside";break}this.offset=J.origin},this._engine=e}destroy(e){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const o=this.container,i=this.pathGenerator;o.shapeDrawers.get(this.shape)?.particleDestroy?.(this);for(const[,t]of o.plugins)t.particleDestroyed?.(this,e);for(const t of o.particles.updaters)t.particleDestroyed?.(this,e);i?.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}async draw(e){const o=this.container,i=o.canvas;for(const[,s]of o.plugins)await i.drawParticlePlugin(s,this,e);await i.drawParticle(this,e)}getFillColor(){return this._getRollColor(this.bubble.color??F(this.color))}getMass(){return this.getRadius()**tt*Math.PI*R}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??F(this.strokeColor))}async init(e,o,i,s){const t=this.container,n=this._engine;this.id=e,this.group=s,this.effectClose=!0,this.effectFill=!0,this.shapeClose=!0,this.shapeFill=!0,this.pathRotation=!1,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const h=t.retina.pixelRatio,l=t.actualOptions,a=Q(this._engine,t,l.particles),m=a.effect.type,f=a.shape.type,{reduceDuplicates:d}=a;this.effect=b(m,this.id,d),this.shape=b(f,this.id,d);const v=a.effect,p=a.shape;if(i){if(i.effect?.type){const u=i.effect.type,w=b(u,this.id,d);w&&(this.effect=w,v.load(i.effect))}if(i.shape?.type){const u=i.shape.type,w=b(u,this.id,d);w&&(this.shape=w,p.load(i.shape))}}this.effectData=it(this.effect,v,this.id,d),this.shapeData=et(this.shape,p,this.id,d),a.load(i);const c=this.effectData;c&&a.load(c.particles);const C=this.shapeData;C&&a.load(C.particles);const x=new U(n,t);x.load(t.actualOptions.interactivity),x.load(a.interactivity),this.interactivity=x,this.effectFill=c?.fill??a.effect.fill,this.effectClose=c?.close??a.effect.close,this.shapeFill=C?.fill??a.shape.fill,this.shapeClose=C?.close??a.shape.close,this.options=a;const P=this.options.move.path;this.pathDelay=D(P.delay.value)*W,P.generator&&(this.pathGenerator=this._engine.getPathGenerator(P.generator),this.pathGenerator&&t.addPath(P.generator,this.pathGenerator)&&await this.pathGenerator.init(t)),t.retina.initParticle(this),this.size=Y(this.options.size,h),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(o),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy();const T=1;this.moveDecay=T-D(this.options.move.decay);const z=t.particles;z.setLastZIndex(this.position.z),this.zIndexFactor=this.position.z/t.zLayers,this.sides=24;let y=t.effectDrawers.get(this.effect);y||(y=this._engine.getEffectDrawer(this.effect),y&&t.effectDrawers.set(this.effect,y)),y?.loadEffect&&await y.loadEffect(this);let g=t.shapeDrawers.get(this.shape);g||(g=this._engine.getShapeDrawer(this.shape),g&&t.shapeDrawers.set(this.shape,g)),g?.loadShape&&await g.loadShape(this);const k=g?.getSidesCount;k&&(this.sides=k(this)),this.spawning=!1,this.shadowColor=j(this.options.shadow.color);for(const u of z.updaters)await u.init(this);for(const u of z.movers)await u.init?.(this);await y?.particleInit?.(t,this),await g?.particleInit?.(t,this);for(const[,u]of t.plugins)u.particleCreated?.(this)}isInsideCanvas(){const e=this.getRadius(),o=this.container.canvas.size,i=this.position;return i.x>=-e&&i.y>=-e&&i.y<=o.height+e&&i.x<=o.width+e}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const e of this.container.particles.updaters)e.reset?.(this)}}export{pt as Particle};
